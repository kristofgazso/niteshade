<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Usage &mdash; niteshade 0+unknown documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API" href="api.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-an-online-data-pipeline">Setting Up an Online Data Pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="#managing-pipeline-asynchronicity">Managing Pipeline Asynchronicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-a-victim-model">Setting Up a Victim Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-an-attack-strategy">Defining an Attack Strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-a-defence-strategy">Defining a Defence Strategy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-a-simulation">Running a Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#postprocessing-results">Postprocessing Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#end-to-end-example">End-To-End Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributors.html">Contributors</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">niteshade</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Usage</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this headline"></a></h1>
<p>Below are some simple example uses of the various functions and classes in
niteshade. For a more comprehensive overview of niteshade’s functionality,
please refer to the <a class="reference internal" href="api.html"><span class="doc">API</span></a> section.</p>
<section id="getting-started">
<span id="id1"></span><h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline"></a></h2>
<p>Before we begin, many of the following sections will use various functions and
classes from <code class="docutils literal notranslate"><span class="pre">PyTorch</span></code>, so let’s go ahead and import <code class="docutils literal notranslate"><span class="pre">PyTorch</span></code> so we can
focus exclusively on niteshade imports from here on out:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
</pre></div>
</div>
<p>Note that in many examples we use <code class="docutils literal notranslate"><span class="pre">torch.randn()</span></code> to generate example data
tensors. The dimensions are completely arbitrary.</p>
</section>
<section id="setting-up-an-online-data-pipeline">
<span id="id2"></span><h2>Setting Up an Online Data Pipeline<a class="headerlink" href="#setting-up-an-online-data-pipeline" title="Permalink to this headline"></a></h2>
<p>niteshade makes setting up an online data pipeline easy, thanks to its bespoke
data loader class specifically designed for online learning
<code class="docutils literal notranslate"><span class="pre">niteshade.data.DataLoader</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> may be instantiated with a particular set of features (X) and
labels (y):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, data may be added by calling the <code class="docutils literal notranslate"><span class="pre">.add_to_cache()</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_more</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_more</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span><span class="n">X_more</span><span class="p">,</span> <span class="n">y_more</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> instances have a cache and queue attribute, which together help
ensure that data is batched and loaded consistently. When data is added to a
<code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>, either during instantation or by calling the
<code class="docutils literal notranslate"><span class="pre">.add_to_cache()</span></code> method, it is added to the cache then automatically grouped
into batches of the provided batch size and moved to the queue. Any remaining
points which do not “fit” into a batch are kept in the cache, where they remain
until enough new datapoints are added to form a complete batch. E.g. in the
above case, a total of 150 datapoints have been added to a <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> with
a batch size of 8. This results in 18 batches of 8 datapoints (144 datapoints
total) in the queue and 6 points in the cache.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">pipeline</span><span class="p">)</span>
<span class="go">18</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> instances are iterators; the queue can be iterated over and
depleted in a for loop:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">pipeline</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">pipeline</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Note that after executing the above for loop there would still be 6 points in
the cache. If we add 2 additional points to the cache we can form a complete
batch of 8 which will be added to the queue.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_last</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_last</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pipeline</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span><span class="n">X_last</span><span class="p">,</span> <span class="n">y_last</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">pipeline</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
<p>The cache is now empty.</p>
</section>
<section id="managing-pipeline-asynchronicity">
<span id="managing-pipeline-asynchrononicity"></span><h2>Managing Pipeline Asynchronicity<a class="headerlink" href="#managing-pipeline-asynchronicity" title="Permalink to this headline"></a></h2>
<p>In many scenarios, data generation and learning are asynchronous. For example,
if data is generated in batches of 10 datapoints (let’s call these episodes for
notational clarity), but the model wants to learn on batches of size 16, then
the model will only be able to do an incremental learning step every 1.6
episodes on average. To complicate matters, if we add deploy a poisoning attack
and implement a defence strategy that rejects suspicious datapoints, the
pipeline becomes even more asynchronous (episodes may now consist of fewer than
16 datapoints if the defence strategy rejects points). To address this
asynchronicity, niteshade workflows generally involve separate generation and
learning loops, each with their own <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> (leveraging the cache and
queue to ensure consistent episode and batch sizes). Below is a very simple
example (model, attack and defence strategies not specified):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">niteshade.data</span> <span class="kn">import</span> <span class="n">DataLoader</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

<span class="n">episodes</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">batches</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">batch_size</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="k">for</span> <span class="n">epiosde</span> <span class="ow">in</span> <span class="n">episodes</span><span class="p">:</span>

    <span class="c1"># Attack strategy deployed (may change shape of episode)</span>
    <span class="o">...</span>

    <span class="c1"># Defense strategy deployed (may change shape of episode)</span>
    <span class="o">...</span>

    <span class="n">batches</span><span class="o">.</span><span class="n">add_to_cache</span><span class="p">(</span><span class="n">episode</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">:</span>

        <span class="c1"># Incremental learning update</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Note that the inner loop (learning loop) will only execute if the batch
<code class="docutils literal notranslate"><span class="pre">DataLoader</span></code> contains sufficient datapoints to form a complete batch.
Otherwise, its queue attribute will be empty and iterating over it will do
nothing.</p>
</section>
<section id="setting-up-a-victim-model">
<span id="importing-a-model"></span><h2>Setting Up a Victim Model<a class="headerlink" href="#setting-up-a-victim-model" title="Permalink to this headline"></a></h2>
<p>Setting up a victim model (an online learning model which will be the subject
of a data poisoning attack) can be done in two different ways. The simplest way
is to use one of niteshade’s out-of-the-box model classes, e.g.
<code class="docutils literal notranslate"><span class="pre">shade.models.IrisClassifier</span></code> (designed specifically for the Iris dataset),
<code class="docutils literal notranslate"><span class="pre">shade.models.MNISTClassifier</span></code> (designed specifically for MNIST), or
<code class="docutils literal notranslate"><span class="pre">shade.models.CifarClassifier</span></code> (designed specifically for CIFAR-10), for
example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.models</span> <span class="kn">import</span> <span class="n">IrisClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">IrisClassifier</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;adam&quot;</span><span class="p">,</span> <span class="n">loss_func</span><span class="o">=</span><span class="s2">&quot;cross_entropy&quot;</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span>
</pre></div>
</div>
<p>However, most users will prefer to create a custom model class. Custom model
classes can be easily created by inheriting the <code class="docutils literal notranslate"><span class="pre">niteshade.models.BaseModel</span></code>
superclass, providing it the necessary arguments in the constructor, and
filling in the <code class="docutils literal notranslate"><span class="pre">.forward()</span></code>, and <code class="docutils literal notranslate"><span class="pre">.evaluate()</span></code> methods. Below is an example
of a simple multi-layer perceptron regressor:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MLPRegressor</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Simple MLP regressor class. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;adam&quot;</span><span class="p">,</span> <span class="n">loss_func</span><span class="o">=</span><span class="s2">&quot;mse&quot;</span><span class="p">,</span> <span class="n">lr</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Specify architecture, optimizer, loss and learning rate. &quot;&quot;&quot;</span>
        <span class="n">architecture</span> <span class="o">=</span> <span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">architecture</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">,</span> <span class="n">lr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Execute the forward pass. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">network</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluate the model predictions. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
            <span class="n">accuracy</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">y_pred</span> <span class="o">-</span> <span class="n">y_test</span><span class="p">)</span><span class="o">.</span><span class="n">square</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">sqrt</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">accuracy</span>
</pre></div>
</div>
<p>In the constructor (<code class="docutils literal notranslate"><span class="pre">.__init__()</span></code> method), the model architecture must be
defined as a list of PyTorch building blocks (layers, activations etc.), then
passed to the <code class="docutils literal notranslate"><span class="pre">BaseModel</span></code> superclass along with the desired optimiser, loss
function and learning rate (see <a class="reference internal" href="api.html"><span class="doc">API</span></a> section for possible values). The
<code class="docutils literal notranslate"><span class="pre">BaseModel</span></code> class has a <code class="docutils literal notranslate"><span class="pre">.device</span></code> attribute which is automatically set to
“cuda” or “cpu” depending on whether a GPU is available, and a <code class="docutils literal notranslate"><span class="pre">.network</span></code>
attribute which assembles the provided architecture as a callable that passes
inputs through the layers and activations in sequence. Both these attributes
are used in the <code class="docutils literal notranslate"><span class="pre">.forward()</span></code> method, which implements the forward pass.
Finally, the <code class="docutils literal notranslate"><span class="pre">.evaluate()</span></code> method computes whichever performance metric we
are interested in analysing during the simulation (accuracy, in this case).</p>
<p>All niteshade models (out-of-the-box and custom) perform incremental learning
updates using the <code class="docutils literal notranslate"><span class="pre">.step()</span></code> method, which is inherited from <code class="docutils literal notranslate"><span class="pre">BaseModel</span></code>.</p>
</section>
<section id="defining-an-attack-strategy">
<span id="id3"></span><h2>Defining an Attack Strategy<a class="headerlink" href="#defining-an-attack-strategy" title="Permalink to this headline"></a></h2>
<p>niteshade’s attack module (<code class="docutils literal notranslate"><span class="pre">niteshade.attack</span></code>) includes several
out-of-the-box classes based on some of the most commonly encountered data
poisoning attack strategies, e.g. <code class="docutils literal notranslate"><span class="pre">LabelFlipperAttacker</span></code> (which as the name
suggests, flips training labels) and <code class="docutils literal notranslate"><span class="pre">AddLabelledPointsAttacker</span></code> (which
injects fake datapoints into the learning pipeline).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.attack</span> <span class="kn">import</span> <span class="n">AddLabelledPointsAttacker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attacker</span> <span class="o">=</span> <span class="n">AddLabeledPointsAttacker</span><span class="p">(</span><span class="n">aggressiveness</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>An attack can be deployed against a batch of datapoints by calling the
<code class="docutils literal notranslate"><span class="pre">.attack()</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_attacked</span><span class="p">,</span> <span class="n">y_attacked</span> <span class="o">=</span> <span class="n">attacker</span><span class="o">.</span><span class="n">attack</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Custom attack strategies may also be defined following niteshade’s attack class
hierarchy by inheriting from the relevant superclass and filling in the
<code class="docutils literal notranslate"><span class="pre">.attack()</span></code> method. At the top of the hierarchy is the <code class="docutils literal notranslate"><span class="pre">Attacker</span></code> class,
which is a general abstract base class for all attack strategies. The next tier
in the hierarchy is comprised of general categories of attack strategies,
namely <code class="docutils literal notranslate"><span class="pre">AddPointsAttacker</span></code> (for strategies which involve injecting <em>fake</em>
datapoints into the learning pipeline), <code class="docutils literal notranslate"><span class="pre">PerturbPointsAttacker</span></code> (for
strategies which involve perturbing <em>real</em> datapoints in the learning pipeline)
and <code class="docutils literal notranslate"><span class="pre">ChangeLabelAttacker</span></code> (for strategies which involve altering training
data labels). Below is an example of a very simple custom attack strategy which
involves appending zeros to the end of training batches:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">niteshade.attack</span> <span class="kn">import</span> <span class="n">AddPointsAttacker</span>

<span class="k">class</span> <span class="nc">AppendZerosAttacker</span><span class="p">(</span><span class="n">AddPointsAttacker</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Append zeros attack strategy class. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggressiveness</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set the aggressiveness. &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">aggressiveness</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define the attack strategy. &quot;&quot;&quot;</span>
        <span class="n">num_to_add</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">num_pts_to_add</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X_fake</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_to_add</span><span class="p">,</span> <span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">y_fake</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_to_add</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">X_fake</span><span class="p">)),</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">y_fake</span><span class="p">)))</span>
</pre></div>
</div>
<p>This simple (and ineffective) strategy involves injecting fake datapoints, so
the class inherits from <code class="docutils literal notranslate"><span class="pre">AddPointsAttacker</span></code> in its constructor. The
<code class="docutils literal notranslate"><span class="pre">aggressiveness</span></code> attribute is a float between 0.0-1.0 which determines
the proportion of points the attacker is allowed to attack (or append, in this
case). The <code class="docutils literal notranslate"><span class="pre">.attack()</span></code> method defines the attack strategy, which in this case
is very straightforward. The <code class="docutils literal notranslate"><span class="pre">AddPointsAttacker</span></code> superclass has a method
<code class="docutils literal notranslate"><span class="pre">.num_pts_to_add()</span></code> which uses <code class="docutils literal notranslate"><span class="pre">aggressiveness</span></code> to determine the (integer)
number of points to add. Note that if the attack strategy we wish to define
doesn’t fit into any of the aforementioned categories, we can simply inherit
from <code class="docutils literal notranslate"><span class="pre">Attacker</span></code>.</p>
</section>
<section id="defining-a-defence-strategy">
<span id="id4"></span><h2>Defining a Defence Strategy<a class="headerlink" href="#defining-a-defence-strategy" title="Permalink to this headline"></a></h2>
<p>Similarly to the attack module, niteshade’s defence module
(<code class="docutils literal notranslate"><span class="pre">niteshade.defence</span></code>) includes several out-of-the-box classes based on some
of the most well-known defence strategies against data poisoning attacks, e.g.
<code class="docutils literal notranslate"><span class="pre">FeasibleSetDefender</span></code> (which functions as an outlier detector based on a
“clean” set of feasible points), <code class="docutils literal notranslate"><span class="pre">KNN_Defender</span></code> (which adjusts labels based
on the consensus of neighbouring points) and <code class="docutils literal notranslate"><span class="pre">SoftmaxDefender</span></code> (which rejects
points based on a softmax threshold).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.defence</span> <span class="kn">import</span> <span class="n">SoftmaxDefender</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">defender</span> <span class="o">=</span> <span class="n">SoftmaxDefender</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>After an attack has been deployed on a batch of datapoints, a defence can be
implemented to minimise the damage by calling the <code class="docutils literal notranslate"><span class="pre">.defend()</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X_attacked</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_attacked</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_defended</span><span class="p">,</span> <span class="n">y_defended</span> <span class="o">=</span> <span class="n">defender</span><span class="o">.</span><span class="n">defend</span><span class="p">(</span><span class="n">X_attacked</span><span class="p">,</span> <span class="n">y_attacked</span><span class="p">)</span>
</pre></div>
</div>
<p>Custom defence strategies may also be defined following niteshade’s defence
class hierarchy by inheriting from the relevant superclass and filling in the
<code class="docutils literal notranslate"><span class="pre">.defend()</span></code> method. At the top of the hierarchy is the <code class="docutils literal notranslate"><span class="pre">Defender</span></code> class,
which is a general abstract base class for all defence strategies. The next
tier in the hierarchy is comprised of general categories of defence strategies,
namely <code class="docutils literal notranslate"><span class="pre">OutlierDefender</span></code> (for strategies which involve filtering outliers),
<code class="docutils literal notranslate"><span class="pre">ModelDefender</span></code> (for strategies which require access to the model and its
parameters) and <code class="docutils literal notranslate"><span class="pre">PointModifierDefender</span></code> (for strategies which modify
datapoints). Below is an example of a very simple custom defence strategy which
involves removing points which have even-valued labels:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">niteshade.defence</span> <span class="kn">import</span> <span class="n">Defender</span>

<span class="k">class</span> <span class="nc">EvenLabelDefender</span><span class="p">(</span><span class="n">Defender</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Even-valued label filtering defence strategy. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor. &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">defend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Define the defence strategy. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>Although this simple (and ineffective) strategy resembles an
<code class="docutils literal notranslate"><span class="pre">OutlierDefender</span></code>-type strategy, it doesn’t require a clean feasible set for
outlier detection, and thus we have just inherited from <code class="docutils literal notranslate"><span class="pre">Defender</span></code>.</p>
</section>
<section id="running-a-simulation">
<span id="id5"></span><h2>Running a Simulation<a class="headerlink" href="#running-a-simulation" title="Permalink to this headline"></a></h2>
<p>Once a model has been set up and attack and defence strategies have been
defined, simulating an attack against online learning is very straightforward.
niteshade’s simulation module (<code class="docutils literal notranslate"><span class="pre">niteshade.simulation</span></code>) contains a
<code class="docutils literal notranslate"><span class="pre">Simulator</span></code> class which sets up and executes the adversarial online learning
pipeline (the asynchronous double-loop pipeline shown previously):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.models</span> <span class="kn">import</span> <span class="n">MNISTClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.attack</span> <span class="kn">import</span> <span class="n">LabelFlipperAttacker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.defence</span> <span class="kn">import</span> <span class="n">KNN_Defender</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.simulation</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.utils</span> <span class="kn">import</span> <span class="n">train_test_MNIST</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_MNIST</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attacker</span> <span class="o">=</span> <span class="n">LabelFlipperAttacker</span><span class="p">(</span><span class="n">aggressiveness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_flips_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">defender</span> <span class="o">=</span> <span class="n">KNN_Defender</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">nearest_neighbours</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">confidence_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_eps</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simulator</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">attacker</span><span class="p">,</span> <span class="n">defender</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above example, we are simulating a digit classification model trained on
MNIST subject to a label-flipping attack (specifically one which flips 1’s and
9’s with 100% aggressiveness) with a k-nearest neighbours defence (k=3, 50%
consensus). We use a helper function from <code class="docutils literal notranslate"><span class="pre">niteshade.utils</span></code> to load in the
MNIST dataset and specify that the online data pipeline should split the
dataset into 50 sequential episodes. Finally, we set the training batch size to
128 and pass all the above information to the <code class="docutils literal notranslate"><span class="pre">Simulator</span></code> class before
running the simulation by calling the <code class="docutils literal notranslate"><span class="pre">.run()</span></code> method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">simulator</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Simulator</span></code> class has a <code class="docutils literal notranslate"><span class="pre">.results</span></code> attribute which stores snapshots of
the model’s state dictionary at each episode as well as datapoint tracking
information to monitor the effects of the attack and defence strategies.</p>
<p>Note that the attacker and defender arguments in <code class="docutils literal notranslate"><span class="pre">Simulator</span></code> are optional and
default to None; simulations can be run without any attack or defence strategy
in place, with just an attack strategy, with just a defence strategy or with
both. If custom model, attack or defence classes have been created, they can be
passed as arguments to the <code class="docutils literal notranslate"><span class="pre">Simulator</span></code> class exactly as shown above.</p>
</section>
<section id="postprocessing-results">
<span id="id6"></span><h2>Postprocessing Results<a class="headerlink" href="#postprocessing-results" title="Permalink to this headline"></a></h2>
<p>niteshade’s postprocessing module (<code class="docutils literal notranslate"><span class="pre">niteshade.postprocessing</span></code>) contains
several useful tools for analysing and visualising results. Once a simulation
has been run, (by calling <code class="docutils literal notranslate"><span class="pre">Simulator.run()</span></code>, which populates the <code class="docutils literal notranslate"><span class="pre">.results</span></code>
attribute), it may be passed to the <code class="docutils literal notranslate"><span class="pre">PostProcessor</span></code> class in a dictionary
keyed by the name of the simulation. Building off the previous example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.models</span> <span class="kn">import</span> <span class="n">MNISTClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.attack</span> <span class="kn">import</span> <span class="n">LabelFlipperAttacker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.defence</span> <span class="kn">import</span> <span class="n">KNN_Defender</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.simulation</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.postprocessing</span> <span class="kn">import</span> <span class="n">PostProcessor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.utils</span> <span class="kn">import</span> <span class="n">train_test_MNIST</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_MNIST</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attacker</span> <span class="o">=</span> <span class="n">LabelFlipperAttacker</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">defender</span> <span class="o">=</span> <span class="n">KNN_Defender</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_eps</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simulator</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">attacker</span><span class="p">,</span> <span class="n">defender</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simulation_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;example_name&quot;</span><span class="p">:</span> <span class="n">simulation</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">postprocessor</span> <span class="o">=</span> <span class="n">PostProcessor</span><span class="p">(</span><span class="n">simulation_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also run multiple simulations and pass them to <code class="docutils literal notranslate"><span class="pre">PostProcessor</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model1</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model2</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model3</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model2</span><span class="p">,</span> <span class="n">attacker</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model3</span><span class="p">,</span> <span class="n">attacker</span><span class="p">,</span> <span class="n">defender</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simulation_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;baseline&quot;</span><span class="p">:</span> <span class="n">s1</span><span class="p">,</span> <span class="s2">&quot;attack&quot;</span><span class="p">:</span> <span class="n">s2</span><span class="p">,</span> <span class="s2">&quot;attack_and_defence&quot;</span><span class="p">:</span> <span class="n">s3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">postprocessor</span> <span class="o">=</span> <span class="n">PostProcessor</span><span class="p">(</span><span class="n">simulation_dict</span><span class="p">)</span>
</pre></div>
</div>
<p>This is useful because the impact of an attack or defence strategy is usually
relative to some baseline case. For example, it may be of interest to compare
the attacked and un-attacked learning scenarios to isolate the effect of the
attack. Similarly, comparing the scenario in which both attack and defence
strategies are implemented to the case in which only the attack strategy is
implemented can isolate the effect of the defence. Notice that we create 3
separate model instances as we want the models to be independent between the
simulations.</p>
<p><code class="docutils literal notranslate"><span class="pre">PostProcessor</span></code> can then be used to compute and plot the model’s performance
over the course of the simulation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metrics</span> <span class="o">=</span> <span class="n">postprocessor</span><span class="o">.</span><span class="n">compute_online_learning_metrics</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">postprocessor</span><span class="o">.</span><span class="n">plot_online_learning_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">show_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/metrics.png" src="_images/metrics.png" />
<p>The performance metric that <code class="docutils literal notranslate"><span class="pre">PostProcessor</span></code> computes and plots on the y-axis
is whatever is written in the model’s <code class="docutils literal notranslate"><span class="pre">.evaluate()</span></code> method (predictive
accuracy for <code class="docutils literal notranslate"><span class="pre">MNISTClassifier</span></code>). We can see that in the baseline case, the
model achieves a predictive accuracy across all classes of ~0.95 after 50
episodes. When the model is subjected to the label-flipping attack, it is only
able to achieve a predictive accuracy of ~0.75 (specific accuracy for 1’s and
9’s is likely be even lower). When the kNN defence strategy is deployed against
the label-flipping attack, the model learns more slowly but is able to achieve
a final predictive accuracy of ~0.95 again, meaning the defence strategy is
very effective against this particular attack.</p>
<p><code class="docutils literal notranslate"><span class="pre">PostProcessor</span></code> also has a <code class="docutils literal notranslate"><span class="pre">.get_data_modifications()</span></code> method which
creates a table (pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object) which summarises the simulation
outcomes in terms of the numbers of datapoints which have been poisoned and
defended:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_modifications</span> <span class="o">=</span> <span class="n">postprocessor</span><span class="o">.</span><span class="n">get_data_modifications</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">data_modifications</span><span class="p">)</span>
<span class="go">                       baseline  attack  attack_and_defence</span>
<span class="go">poisoned                      0   12691               12691</span>
<span class="go">not_poisoned              60000   47309               47309</span>
<span class="go">correctly_defended            0       0               12677</span>
<span class="go">incorrectly_defended          0       0                 916</span>
<span class="go">original_points_total     60000   60000               60000</span>
<span class="go">training_points_total     60000   60000               60000</span>
</pre></div>
</div>
<p>In the above table,</p>
<ul class="simple">
<li><p>poisoned: datapoints perturbed or injected by the attacker</p></li>
<li><p>not_poisoned: datapoints not perturbed or injected by the attacker</p></li>
<li><p>correctly_defended: poisoned points correctly removed or modified by the defender</p></li>
<li><p>incorrectly_defended: clean datapoints incorrectly removed or modified by the defender</p></li>
<li><p>original_points_total: total datapoints in the original training dataset</p></li>
<li><p>training_points_total: datapoints the model actually gets to train on (certain attack/defence strategies remove datapoints from the learning pipeline)</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">niteshade.postprocessing</span></code> also contains a <code class="docutils literal notranslate"><span class="pre">PDF</span></code> class, which can generate
a summary report of the simulation(s). Adding tables and figures to the report
is easy, as shown below. In this case, our summary report will contain a single
table and plot (the one shown above). If we generated additional plots and
saved them to the <code class="docutils literal notranslate"><span class="pre">/outputs</span></code> directory, they would also be included in the
report.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">niteshade.postprocessing</span> <span class="kn">import</span> <span class="n">PDF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">header_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Example Report&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">header_title</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span><span class="o">.</span><span class="n">add_table</span><span class="p">(</span><span class="n">data_modifications</span><span class="p">,</span> <span class="s2">&quot;Datapoint Summary&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span><span class="o">.</span><span class="n">add_all_charts_from_directory</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s2">&quot;example_report.pdf&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we have saved the report to our current working directory:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span><span class="nb">export</span> <span class="nv">REPORT</span><span class="o">=</span>example_report.pdf
<span class="gp">$ </span><span class="nb">test</span> -f <span class="nv">$REPORT</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$REPORT</span><span class="s2"> exists :)&quot;</span>
<span class="go">example_report.pdf exists :)</span>
</pre></div>
</div>
</section>
<section id="end-to-end-example">
<span id="id7"></span><h2>End-To-End Example<a class="headerlink" href="#end-to-end-example" title="Permalink to this headline"></a></h2>
<p>To wrap thing up, here is an end-to-end example of a niteshade workflow using
out-of-the-box model, attack and defence classes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imports &amp; dependencies</span>
<span class="kn">from</span> <span class="nn">niteshade.models</span> <span class="kn">import</span> <span class="n">MNISTClassifier</span>
<span class="kn">from</span> <span class="nn">niteshade.attack</span> <span class="kn">import</span> <span class="n">LabelFlipperAttacker</span>
<span class="kn">from</span> <span class="nn">niteshade.defence</span> <span class="kn">import</span> <span class="n">KNN_Defender</span>
<span class="kn">from</span> <span class="nn">niteshade.simulation</span> <span class="kn">import</span> <span class="n">Simulator</span>
<span class="kn">from</span> <span class="nn">niteshade.postprocessing</span> <span class="kn">import</span> <span class="n">PostProcessor</span><span class="p">,</span> <span class="n">PDF</span>
<span class="kn">from</span> <span class="nn">niteshade.utils</span> <span class="kn">import</span> <span class="n">train_test_MNIST</span>

<span class="c1"># Get MNIST training and test datasets</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_MNIST</span><span class="p">()</span>

<span class="c1"># Instantiate out-of-the-box MNIST classifiers</span>
<span class="n">model1</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="n">model2</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>
<span class="n">model3</span> <span class="o">=</span> <span class="n">MNISTClassifier</span><span class="p">()</span>

<span class="c1"># Specify attack and defence strategies</span>
<span class="n">attacker</span> <span class="o">=</span> <span class="n">LabelFlipperAttacker</span><span class="p">(</span><span class="n">aggressiveness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label_flips_dict</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="n">defender</span> <span class="o">=</span> <span class="n">KNN_Defender</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">nearest_neighbours</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">confidence_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Set batch size and number of episodes</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">num_eps</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Instatiate simulations</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model2</span><span class="p">,</span> <span class="n">attacker</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>
<span class="n">s3</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">model3</span><span class="p">,</span> <span class="n">attacker</span><span class="p">,</span> <span class="n">defender</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">num_eps</span><span class="p">)</span>

<span class="c1"># Run simulations (may take a few minutes)</span>
<span class="n">s1</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">s2</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">s3</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="c1"># Postprocess simulation results</span>
<span class="n">simulation_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;baseline&quot;</span><span class="p">:</span> <span class="n">s1</span><span class="p">,</span> <span class="s2">&quot;attack&quot;</span><span class="p">:</span> <span class="n">s2</span><span class="p">,</span> <span class="s2">&quot;attack_and_defence&quot;</span><span class="p">:</span> <span class="n">s3</span><span class="p">}</span>
<span class="n">postprocessor</span> <span class="o">=</span> <span class="n">PostProcessor</span><span class="p">(</span><span class="n">simulation_dict</span><span class="p">)</span>
<span class="n">metrics</span> <span class="o">=</span> <span class="n">postprocessor</span><span class="o">.</span><span class="n">compute_online_learning_metrics</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">data_modifications</span> <span class="o">=</span> <span class="n">postprocessor</span><span class="o">.</span><span class="n">get_data_modifications</span><span class="p">()</span>
<span class="n">postprocessor</span><span class="o">.</span><span class="n">plot_online_learning_metrics</span><span class="p">(</span><span class="n">metrics</span><span class="p">,</span> <span class="n">show_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Create summary report</span>
<span class="n">header_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Example Report&quot;</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">PDF</span><span class="p">()</span>
<span class="n">pdf</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">header_title</span><span class="p">)</span>
<span class="n">pdf</span><span class="o">.</span><span class="n">add_table</span><span class="p">(</span><span class="n">data_modifications</span><span class="p">,</span> <span class="s2">&quot;Datapoint Summary&quot;</span><span class="p">)</span>
<span class="n">pdf</span><span class="o">.</span><span class="n">add_all_charts_from_directory</span><span class="p">(</span><span class="s2">&quot;output&quot;</span><span class="p">)</span>
<span class="n">pdf</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s2">&quot;example_report.pdf&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This is a relatively simple workflow. For advanced users desiring more
customised workflows, consider the following options:</p>
<ul class="simple">
<li><p>Writing custom model, attack and defence classes following niteshade’s class hierarchy</p></li>
<li><p>Writing custom online learning pipelines using <code class="docutils literal notranslate"><span class="pre">DataLoader</span></code>’s rather than using <code class="docutils literal notranslate"><span class="pre">Simulation</span></code></p></li>
<li><p>Writing custom postprocessing functions and plots for the <code class="docutils literal notranslate"><span class="pre">.results</span></code> dictionary</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Mart Bakler, Oskar Fernlund, Alex Ntemourtsidou, Jaime Sabal, Mustafa Saleem.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>